#!/usr/bin/python3
import curses, sys, os, locale, stat, signal

locale.setlocale(locale.LC_ALL, "")

def _is_tty_path(p):
    try:
        st = os.stat(p)
        return stat.S_ISCHR(st.st_mode) and (p.startswith("/dev/pts/") or p.startswith("/dev/tty"))
    except Exception:
        return False

def _attach_tty(tty_path):
    pw_fd = os.dup(1)
    fd = os.open(tty_path, os.O_RDWR | os.O_CLOEXEC)
    os.dup2(fd, 0); os.dup2(fd, 1); os.dup2(fd, 2)
    os.close(fd)
    return pw_fd

def _fallback_readline(pw_fd):
    sys.stderr.write("Password: "); sys.stderr.flush()
    pw = sys.stdin.readline().rstrip("\n")
    data = (pw + "\n").encode()
    try:
        if pw_fd is not None:
            os.write(pw_fd, data); os.close(pw_fd)
        else:
            sys.stdout.write(pw + "\n"); sys.stdout.flush()
    except Exception:
        pass
    sys.exit(0)

def _prompt_password_curses(stdscr, pw_fd):
    curses.curs_set(0)
    stdscr.keypad(True)
    curses.noecho()
    curses.cbreak()
    if curses.has_colors():
        curses.start_color()
        try: curses.use_default_colors()
        except Exception: pass
        curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLUE)
    password = ""
    while True:
        stdscr.erase()
        h, w = stdscr.getmaxyx()
        dw, dh = max(44, w // 2), 9
        dx, dy = (w - dw) // 2, max(2, (h - dh) // 2)
        win = curses.newwin(dh, dw, dy, dx)
        if curses.has_colors():
            win.bkgd(' ', curses.color_pair(1))
        win.box()
        title = " Authentication "
        win.attron(curses.A_BOLD); win.addstr(0, max(1, (dw - len(title)) // 2), title); win.attroff(curses.A_BOLD)
        label = "Password:"
        win.addstr(4, 2, label)
        field_w = dw - len(label) - 6
        fx, fy = len(label) + 3, 4
        win.attron(curses.A_REVERSE)
        win.addstr(fy, fx, " " * field_w)
        win.addstr(fy, fx, ("•" * len(password))[-field_w:])
        win.attroff(curses.A_REVERSE)
        hint = "Enter = Submit • Esc = Cancel"
        win.addstr(dh - 2, max(2, (dw - len(hint)) // 2), hint[:dw-4])
        stdscr.refresh(); win.refresh()
        k = stdscr.getch()
        if k == curses.KEY_RESIZE:
            continue
        if k in (27, 3):
            curses.endwin()
            try: os.close(pw_fd)
            except Exception: pass
            sys.exit(130)
        if k in (curses.KEY_BACKSPACE, 127, 8):
            if password:
                password = password[:-1]
            continue
        if k in (curses.KEY_ENTER, 10, 13):
            curses.endwin()
            try: os.write(pw_fd, (password + "\n").encode())
            finally:
                try: os.close(pw_fd)
                except Exception: pass
            sys.exit(0)
        if 0 <= k <= 255:
            ch = chr(k)
            if ch not in ("\n", "\r"):
                password += ch

def main():
    for sig in (signal.SIGINT, signal.SIGTERM):
        signal.signal(sig, lambda *_: sys.exit(130))
    tty = os.environ.get("SUSH_TTY", "")
    pw_fd = None
    if not _is_tty_path(tty):
        try:
            if sys.stdin.isatty():
                tty = os.ttyname(0)
        except Exception:
            pass
    if not _is_tty_path(tty) and _is_tty_path("/dev/tty"):
        tty = "/dev/tty"
    if not tty:
        _fallback_readline(pw_fd)
    try:
        pw_fd = _attach_tty(tty)
    except Exception:
        _fallback_readline(pw_fd)
    try:
        curses.wrapper(_prompt_password_curses, pw_fd)
    except curses.error:
        _fallback_readline(pw_fd)

if __name__ == "__main__":
    main()
